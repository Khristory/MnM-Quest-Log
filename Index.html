<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Monsters & Memories — Quest Log (Mobile Share + Paste Import)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#111418;--panel:#1b1f26;--muted:#8ea0b5;--accent:#ffd166;--accent-2:#06d6a0;--danger:#ef476f;
    --text:#e9eef5;--text-dim:#b7c4d4;--card:#202632;--card-2:#283243;--border:#2b3442;--radius:12px;
    --sidebar-w:300px; --sidebar-w-collapsed:48px;
  }
  *{box-sizing:border-box}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font:15px/1.4 system-ui,Segoe UI,Roboto,Inter,Ubuntu,Arial;
    display:grid; grid-template-columns:var(--sidebar-w) 1fr; grid-template-rows:auto 1fr;
    min-height:100vh; transition:grid-template-columns .2s ease;
  }
  body.sidebar-collapsed{ grid-template-columns:var(--sidebar-w-collapsed) 1fr; }

  header{grid-column:1/-1; padding:10px 16px; background:linear-gradient(180deg,#141922,transparent); border-bottom:1px solid var(--border)}
  h1{margin:0; font-size:20px; color:var(--accent)}
  .wrap{display:contents}

  /* Sidebar (tree) */
  .sidebar{border-right:1px solid var(--border); background:var(--panel); display:flex; flex-direction:column; overflow:hidden}
  .sidebar-head{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px; border-bottom:1px solid var(--border)}
  .sidebar-title{font-size:12px; color:var(--muted); letter-spacing:.06em; text-transform:uppercase}
  .sidebar-toggle{border:1px solid var(--border); background:#ffffff10; color:#fff; border-radius:10px; padding:6px 10px; cursor:pointer; font-size:12px}

  .sidebar-inner{padding:8px; display:flex; flex-direction:column; gap:10px; overflow:auto}
  body.sidebar-collapsed .sidebar-title, body.sidebar-collapsed .sidebar-inner{display:none}

  .tree{display:block}
  .tree-row{
    display:flex; align-items:center; gap:8px;
    padding:6px 8px; border-radius:10px; border:1px solid transparent; cursor:pointer;
  }
  .tree-row:hover{ background:#ffffff08; }
  .tree-row.active{ background:var(--card-2); border-color:var(--accent); }
  .twisty{width:18px; text-align:center; user-select:none; font-size:12px; opacity:.9}
  .twisty.invisible{visibility:hidden}
  .node-title{flex:1; min-width:0}
  .title-text{white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
  .badge{font-size:11px; background:var(--accent-2); color:#06261e; padding:2px 8px; border-radius:999px; font-weight:700}

  .mini-actions{display:grid; grid-template-columns:1fr 1fr; gap:6px}
  .sidebar-actions{display:grid; grid-template-columns:1fr 1fr; gap:6px}

  /* Main controls */
  .input,.textarea{width:100%; padding:9px 11px; border-radius:10px; background:#0f1319; border:1px solid var(--border); color:#fff}
  .textarea{min-height:90px; resize:vertical}
  .btn{border:none; border-radius:10px; padding:6px 10px; cursor:pointer; font-size:13px}
  .btn.secondary{background:#ffffff14; color:#fff}
  .btn.danger{background:var(--danger); color:#fff}
  .btn.success{background:var(--accent-2); color:#06261e}
  .btn.main{background:var(--accent); color:#1a1a1a; font-weight:700}
  .chip{background:#ffffff14; color:#b7c4d4; padding:6px 10px; border-radius:999px; border:1px solid var(--border); font-size:12px}

  /* Main area */
  .main{padding:8px 16px 16px; overflow:auto; display:flex; flex-direction:column; gap:12px}
  .card{background:var(--card); border:1px solid var(--border); border-radius:var(--radius); padding:12px}
  .empty{padding:14px; border:1px dashed var(--border); border-radius:12px; color:var(--muted); text-align:center}
  .storage-row{display:flex; gap:8px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  .subtle{color:var(--text-dim); font-size:12px; margin-top:6px}

  .grid-2{display:grid; grid-template-columns:1fr; gap:12px; align-items:start}
  @media (min-width: 860px){ .grid-2{grid-template-columns:1fr auto} }
  details.add, details.tools{border:1px solid var(--border); border-radius:12px; background:var(--card)}
  details.add>summary, details.tools>summary{list-style:none; cursor:pointer; padding:12px; user-select:none; display:flex; align-items:center; justify-content:space-between; font-weight:700}
  details.add[open]>summary, details.tools[open]>summary{border-bottom:1px solid var(--border)}
  details.add .content, details.tools .content{padding:12px}

  /* Quests */
  .quest{background:var(--panel); border:1px solid var(--border); border-radius:12px; margin-top:8px}
  .quest.done{opacity:.72}
  .quest-header{display:flex; justify-content:space-between; align-items:center; padding:10px 12px; cursor:pointer}
  .quest-name{font-weight:700}
  .quest-body{display:none; padding:10px 12px 12px; border-top:1px solid var(--border)}
  .quest.open .quest-body{display:block}
  .muted{color:var(--text-dim); white-space:pre-wrap; margin:8px 0}
  .stack-h{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}

  /* Floating inline editor for node titles */
  .floating-editor{
    position:fixed; z-index:9999; display:flex; gap:6px; align-items:center;
    background:var(--panel); border:1px solid var(--border); border-radius:10px; padding:6px;
    box-shadow:0 8px 24px rgba(0,0,0,.5);
  }
  .floating-input{
    font-size:14px; line-height:1.25;
    background:#0f1319; color:#fff; border:1px solid var(--border); border-radius:8px;
    padding:6px 8px; white-space:nowrap; overflow:hidden;
  }
  .icon-btn{border:none; background:#ffffff14; color:#fff; padding:6px 10px; border-radius:8px; cursor:pointer; font-size:12px}
  .icon-btn.secondary{background:#ffffff10; color:#b7c4d4}
  .icon-btn:hover{background:#ffffff22}
</style>
</head>
<body>
<header><h1>Monsters & Memories — Quest Log</h1></header>

<div class="wrap">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="sidebar-head">
      <div class="sidebar-title">Characters & Sub-sections</div>
      <button id="sidebarToggle" class="sidebar-toggle" title="Toggle sidebar">◂</button>
    </div>
    <div class="sidebar-inner">
      <div id="tree" class="tree"></div>

      <div class="mini-actions">
        <button id="expandAllBtn" class="btn secondary" title="Expand all nodes">Expand All</button>
        <button id="collapseAllBtn" class="btn secondary" title="Collapse all nodes">Collapse All</button>
      </div>

      <div class="sidebar-actions">
        <button id="addCharacterBtn" class="btn main">Add Character</button>
        <button id="addChildBtn" class="btn secondary">Add Sub-section</button>
        <button id="renameNodeBtn" class="btn secondary">Rename</button>
        <button id="deleteNodeBtn" class="btn danger">Delete</button>
      </div>

      <div class="card" style="margin-top:8px">
        <button id="exportBtn" class="btn secondary" style="width:100%">Export (JSON)</button>
        <input id="importFile" type="file" accept=".json,.txt" class="input" />
        <button id="pasteToggleBtn" class="btn secondary" style="width:100%">Paste Import</button>
        <textarea id="pasteBox" class="textarea" placeholder="Paste JSON here" style="display:none;margin-top:6px"></textarea>
        <button id="pasteLoadBtn" class="btn success" style="display:none;width:100%">Load Pasted JSON</button>
        <button id="clearAllBtn" class="btn danger" style="width:100%; margin-top:6px">Clear All</button>
      </div>
    </div>
  </aside>

  <!-- Main -->
  <main class="main">
    <div class="card">
      <div class="storage-row">
        <div id="fileStatus" class="chip">Storage: Local (browser)</div>
        <div class="stack-h">
          <button id="connectFileBtn" class="btn main">Connect File</button>
          <button id="createFileBtn" class="btn secondary">Create File</button>
          <button id="saveBtn" class="btn success" title="Ctrl/Cmd+S">Save</button>
          <button id="shareBtn" class="btn secondary" title="Share or copy JSON (best on phones)">Share</button>
        </div>
      </div>
      <div id="fsWarning" class="subtle" style="display:none"></div>
      <div id="lastSaved" class="subtle">Last saved: —</div>
    </div>

    <div id="crumb" class="card">No node selected</div>

    <div class="grid-2">
      <!-- Add Quest (form-based, robust) -->
      <details class="add" open>
        <summary>Add Quest</summary>
        <div class="content">
          <form id="addQuestForm" style="display:grid; gap:8px">
            <input id="questName" class="input" placeholder="Quest name" />
            <textarea id="questDesc" class="textarea" placeholder="Description / objectives / NPC notes…"></textarea>
            <div style="display:flex; justify-content:flex-end; gap:8px">
              <button id="addQuestBtn" type="submit" class="btn main">Add Quest</button>
            </div>
            <div id="addQuestError" style="display:none; color:#ef9aa8; font-size:12px">
              Please enter a name or a description.
            </div>
          </form>
        </div>
      </details>

      <!-- Node Tools -->
      <details class="tools" open>
        <summary>Node Tools</summary>
        <div class="content">
          <div class="stack-h">
            <button id="markAllDoneBtn" class="btn secondary">Mark All Done</button>
            <button id="purgeDoneBtn" class="btn danger">Delete Done</button>
          </div>
        </div>
      </details>
    </div>

    <div class="card">
      <strong>Quests</strong>
      <div id="questList"></div>
      <div id="emptyState" class="empty" style="display:none">No quests yet in this node</div>
    </div>
  </main>
</div>

<script>
/* ================== Core state ================== */
const STORAGE_KEY="mnm_tree_questlog_v1";
const SIDEBAR_KEY="mnm_sidebar_collapsed";

let state = load();
let fileHandle = null;

const supportsFS = !!(window.showOpenFilePicker && window.showSaveFilePicker);
const secureOK = window.isSecureContext || location.protocol==="https:" || location.hostname==="localhost";
const el = (id)=>document.getElementById(id);

/* ================== Defaults ================== */
function defaultState(){
  const rootId = uid();
  return { tree: [{ id:rootId, title:"Main Character", open:true, quests:[], children:[] }], selectedNodeId: rootId };
}
function uid(){ return Math.random().toString(36).slice(2,9); }

/* ================== Persistence ================== */
function save(data=state){ localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }
function load(){ try{ const raw=localStorage.getItem(STORAGE_KEY); if(raw){ const s=JSON.parse(raw); if(s.tree) return s; } }catch{} return defaultState(); }
function setStatus(msg){ el("fileStatus").textContent = msg; }
function warnFS(msg){ const w=el("fsWarning"); w.textContent=msg; w.style.display=msg? "block":"none"; }
function stampSaved(method, name){ const ts=new Date().toLocaleString(); el("lastSaved").textContent = `Last saved: ${ts} via ${method}${name?` (${name})`:""}`; }

/* ================== File helpers ================== */
async function ensurePermission(){ if(!fileHandle) return false; let p=await fileHandle.queryPermission({mode:'readwrite'}); if(p==='prompt') p=await fileHandle.requestPermission({mode:'readwrite'}); return p==='granted'; }
async function writeToHandle(handle){ const w=await handle.createWritable(); await w.write(JSON.stringify(state,null,2)); await w.close(); }
async function hardSave(){
  if(fileHandle && supportsFS && secureOK){ try{ if(await ensurePermission()){ await writeToHandle(fileHandle); setStatus(`Saved to: ${fileHandle.name}`); stampSaved("connected file", fileHandle.name); return; } }catch(e){} }
  if(supportsFS && secureOK){ try{ const handle=await window.showSaveFilePicker({ suggestedName:(fileHandle?.name)||"mnm-questlog.json", types:[{description:"JSON", accept:{ "application/json":[".json"] }}] }); await writeToHandle(handle); fileHandle=handle; setStatus(`Saved to: ${fileHandle.name}`); stampSaved("Save As", fileHandle.name); return; }catch(e){} }
  const blob=new Blob([JSON.stringify(state,null,2)],{type:"application/json"}); const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=(fileHandle?.name)||"mnm-questlog.json"; a.click(); setStatus("Downloaded JSON"); stampSaved("download");
}

/* ======= Mobile-friendly Share / Copy JSON ======= */
async function shareJSON(){
  const json = JSON.stringify(state, null, 2);
  const blob = new Blob([json], {type:"application/json"});
  const file = new File([blob], "mnm-questlog.json", {type:"application/json"});

  try{
    if(navigator.canShare && navigator.canShare({ files:[file] })){
      await navigator.share({ files:[file], title:"Quest Log", text:"Monsters & Memories quest log" });
      setStatus("Shared JSON"); stampSaved("share");
      return;
    }
  }catch(e){ /* fall through */ }

  // Fallback: copy to clipboard
  try{
    await navigator.clipboard.writeText(json);
    setStatus("Copied JSON to clipboard"); stampSaved("clipboard");
    return;
  }catch(e){ /* fall through */ }

  // Final fallback: download
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob); a.download="mnm-questlog.json"; a.click();
  setStatus("Downloaded JSON"); stampSaved("download");
}

/* ================== Tree helpers ================== */
function findNodeAndParent(id){
  function walk(nodes, parent=null, path=[]){
    for(const n of nodes){
      const np=[...path,n];
      if(n.id===id) return {node:n, parent, path:np};
      if(n.children?.length){ const r=walk(n.children, n, np); if(r) return r; }
    } return null;
  } return walk(state.tree, null, []);
}
function currentNode(){ const sel=state.selectedNodeId; if(!sel) return state.tree[0]||null; const r=findNodeAndParent(sel); return r?.node || (state.tree[0]||null); }
function countsForNode(node){ const total=node.quests?.length||0; const done=(node.quests||[]).filter(q=>q.done).length; return {done,total}; }
function setOpenRecursive(node, open){ node.open=open; node.children?.forEach(ch=>setOpenRecursive(ch,open)); }
function expandAll(){ state.tree.forEach(n=>setOpenRecursive(n,true)); save(); renderTree(); }
function collapseAll(){ state.tree.forEach(n=>setOpenRecursive(n,false)); save(); renderTree(); }

/* ================== Floating inline editor ================== */
let floating = null, floatingInput = null, widthMirror = null, editingId = null;
function ensureMirror(){
  if(!widthMirror){
    widthMirror = document.createElement("span");
    widthMirror.style.position="fixed"; widthMirror.style.visibility="hidden"; widthMirror.style.whiteSpace="pre";
    widthMirror.style.font="14px/1.25 system-ui,Segoe UI,Roboto,Inter,Ubuntu,Arial";
    widthMirror.style.padding="0 8px"; widthMirror.style.border="1px solid transparent";
    document.body.appendChild(widthMirror);
  }
}
function autosizeInput(){
  if(!floatingInput) return;
  ensureMirror();
  widthMirror.textContent = floatingInput.value || " ";
  const w = Math.min(900, Math.max(180, widthMirror.offsetWidth + 20));
  floatingInput.style.width = w + "px";
}
function positionFloating(){
  if(!floating || !editingId) return;
  const row = document.querySelector(`.tree-row[data-node="${editingId}"]`);
  if(!row) return;
  const rect = row.getBoundingClientRect();
  const left = rect.left + 22 + window.scrollX;
  const top  = rect.top + window.scrollY - 2;
  floating.style.left = left + "px";
  floating.style.top  = top + "px";
}
function startEditNodeTitle(id){
  editingId = id;
  const r = findNodeAndParent(id); if(!r) return;
  if(floating) floating.remove();
  floating = document.createElement("div");
  floating.className = "floating-editor";
  floating.setAttribute("data-node", id);

  floatingInput = document.createElement("input");
  floatingInput.type="text";
  floatingInput.className="floating-input";
  floatingInput.value = r.node.title || "";
  autosizeInput();

  const saveBtn = document.createElement("button"); saveBtn.className="icon-btn"; saveBtn.textContent="Save";
  const cancelBtn = document.createElement("button"); cancelBtn.className="icon-btn secondary"; cancelBtn.textContent="Cancel";

  saveBtn.onclick = ()=> commitEditNodeTitle(id, floatingInput.value);
  cancelBtn.onclick = ()=> cancelEditNodeTitle();

  floatingInput.addEventListener("input", autosizeInput);
  floatingInput.addEventListener("keydown",(e)=>{
    if(e.key==="Enter" && !e.shiftKey){ e.preventDefault(); commitEditNodeTitle(id, floatingInput.value); }
    if((e.key==="Enter" && (e.ctrlKey||e.metaKey))){ e.preventDefault(); commitEditNodeTitle(id, floatingInput.value); }
    if(e.key==="Escape"){ e.preventDefault(); cancelEditNodeTitle(); }
  });

  floating.append(floatingInput, saveBtn, cancelBtn);
  document.body.appendChild(floating);
  positionFloating();
  requestAnimationFrame(()=>{ floatingInput.focus(); floatingInput.select(); autosizeInput(); });

  window.addEventListener("scroll", positionFloating, {passive:true});
  window.addEventListener("resize", positionFloating);
}
function commitEditNodeTitle(id, value){
  const r=findNodeAndParent(id); if(!r) return cancelEditNodeTitle();
  const next=(value||"").trim() || "Untitled";
  r.node.title = next;
  cancelEditNodeTitle();
  save(); render();
}
function cancelEditNodeTitle(){
  editingId = null;
  if(floating){ floating.remove(); floating=null; }
  floatingInput=null;
  window.removeEventListener("scroll", positionFloating);
  window.removeEventListener("resize", positionFloating);
}

/* ================== Render UI ================== */
function render(){ renderTree(); renderCrumb(); renderQuests(); }
function renderTree(){
  const host=el("tree"); host.innerHTML="";
  function row(node, depth){
    const r=document.createElement("div");
    r.className="tree-row"+(node.id===state.selectedNodeId?" active":"");
    r.style.paddingLeft = (8 + depth*16) + "px";
    r.setAttribute("data-node", node.id);

    const twist=document.createElement("div");
    twist.className="twisty"+((node.children?.length)? "" : " invisible");
    twist.textContent = node.open? "▾" : "▸";
    twist.title="Click to toggle. Alt+Click toggles entire subtree.";
    twist.onclick=(e)=>{ e.stopPropagation(); if(e.altKey){ setOpenRecursive(node, !node.open); } else { node.open=!node.open; } save(); renderTree(); };

    const titleWrap=document.createElement("div"); titleWrap.className="node-title";
    const text=document.createElement("div"); text.className="title-text"; text.textContent=node.title||"Untitled";
    text.title=node.title||"Untitled";
    text.ondblclick=(e)=>{ e.stopPropagation(); startEditNodeTitle(node.id); };
    titleWrap.appendChild(text);

    const {done,total}=countsForNode(node);
    const badge=document.createElement("div"); badge.className="badge"; badge.textContent=`${done}/${total}`;

    r.append(twist,titleWrap,badge);
    r.onclick=()=>{ state.selectedNodeId=node.id; save(); render(); };
    host.appendChild(r);

    if(node.open && node.children?.length){ node.children.forEach(ch=>row(ch, depth+1)); }
  }
  state.tree.forEach(n=>row(n,0));
}
function renderCrumb(){
  const r=findNodeAndParent(state.selectedNodeId);
  if(!r){ el("crumb").textContent="No node selected"; return; }
  el("crumb").textContent = "Path: " + r.path.map(n=>n.title||"Untitled").join(" › ");
}
function renderQuests(){
  const node=currentNode();
  const list=el("questList");
  if(!node){ list.innerHTML=""; el("emptyState").style.display="block"; return; }

  list.innerHTML="";
  const qs=node.quests||[];
  if(qs.length===0){ el("emptyState").style.display="block"; return; }
  el("emptyState").style.display="none";

  qs.forEach(q=>{
    const card=document.createElement("div"); card.className="quest"+(q.done?" done":"")+(q.open?" open":"");
    const head=document.createElement("div"); head.className="quest-header"; head.innerHTML=`<div class="quest-name">${q.name}</div>`;
    head.onclick=()=>{ q.open=!q.open; save(); renderQuests(); };

    const body=document.createElement("div"); body.className="quest-body";
    if(q.editing){
      const nameInput=document.createElement("input"); nameInput.className="input"; nameInput.value=q.name; nameInput.placeholder="Quest name";
      const descTextarea=document.createElement("textarea"); descTextarea.className="textarea"; descTextarea.placeholder="Description…"; descTextarea.value=q.desc||"";
      const actions=document.createElement("div"); actions.className="stack-h";
      const saveBtn=document.createElement("button"); saveBtn.className="btn success"; saveBtn.textContent="Save";
      const cancelBtn=document.createElement("button"); cancelBtn.className="btn secondary"; cancelBtn.textContent="Cancel";
      saveBtn.onclick=(e)=>{e.stopPropagation(); commitEdit(q,nameInput.value,descTextarea.value);};
      cancelBtn.onclick=(e)=>{e.stopPropagation(); cancelEdit(q);};
      nameInput.addEventListener("keydown",(e)=>{ if(e.key==="Enter"&&(e.ctrlKey||e.metaKey)) commitEdit(q,nameInput.value,descTextarea.value); if(e.key==="Escape") cancelEdit(q);});
      descTextarea.addEventListener("keydown",(e)=>{ if(e.key==="Enter"&&(e.ctrlKey||e.metaKey)) commitEdit(q,nameInput.value,descTextarea.value); if(e.key==="Escape") cancelEdit(q);});
      actions.append(saveBtn,cancelBtn); body.append(nameInput,descTextarea,actions);
      setTimeout(()=>nameInput.focus(),0);
    } else {
      const desc=document.createElement("div"); desc.className="muted"; desc.textContent=q.desc||"—";
      const actions=document.createElement("div"); actions.className="stack-h";
      const editBtn=document.createElement("button"); editBtn.className="btn secondary"; editBtn.textContent="Edit";
      const doneBtn=document.createElement("button"); doneBtn.className="btn success"; doneBtn.textContent=q.done?"Undo":"Done";
      const delBtn=document.createElement("button"); delBtn.className="btn danger"; delBtn.textContent="Delete";
      editBtn.onclick=(e)=>{e.stopPropagation(); q.editing=true; q.open=true; save(); renderQuests();};
      doneBtn.onclick=(e)=>{e.stopPropagation(); q.done=!q.done; save(); render();};
      delBtn.onclick=(e)=>{e.stopPropagation(); node.quests=node.quests.filter(x=>x.id!==q.id); save(); render();};
      actions.append(editBtn,doneBtn,delBtn); body.append(desc,actions);
    }
    card.append(head,body); list.appendChild(card);
  });
}
function commitEdit(q, nextName, nextDesc){ const name=(nextName||"").trim(); const desc=(nextDesc||"").trim(); if(name) q.name=name; q.desc=desc; q.editing=false; q.open=true; save(); render(); }
function cancelEdit(q){ q.editing=false; save(); renderQuests(); }

/* ================== Node actions ================== */
function addCharacter(){ const id=uid(); state.tree.push({ id, title:"New Character", open:true, quests:[], children:[] }); state.selectedNodeId=id; save(); render(); startEditNodeTitle(id); }
function addChild(){ const sel=currentNode(); if(!sel) return alert("Select a node first."); const id=uid(); sel.children=sel.children||[]; sel.open=true; sel.children.push({ id, title:"New Sub-section", open:true, quests:[], children:[] }); state.selectedNodeId=id; save(); render(); startEditNodeTitle(id); }
function renameNode(){ const sel=currentNode(); if(!sel) return alert("Select a node first."); startEditNodeTitle(sel.id); }
function deleteNode(){
  const r=findNodeAndParent(state.selectedNodeId); if(!r) return alert("Select a node first.");
  if(!confirm(`Delete "${r.node.title}" and everything inside it?`)) return;
  if(r.parent){ r.parent.children=(r.parent.children||[]).filter(x=>x.id!==r.node.id); state.selectedNodeId=r.parent.id; }
  else{ state.tree=state.tree.filter(x=>x.id!==r.node.id); state.selectedNodeId=state.tree[0]?.id||null; }
  save(); render();
}

/* ================== Import/Export helpers ================== */
function exportJSON(){ const blob=new Blob([JSON.stringify(state,null,2)],{type:"application/json"}); const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="mnm-questlog.json"; a.click(); }
async function readAndImportFile(file){
  const text=await file.text();
  await importFromText(text);
}
async function importFromText(text){
  try{
    const data=JSON.parse(text);
    if(Array.isArray(data.tree)){
      state = data;                  // full state
    }else if(Array.isArray(data.sections)){
      state={ tree:data.sections.map(s=>({id:uid(),title:s.title||"Untitled",open:true,quests:s.quests||[],children:[] })), selectedNodeId:null };
      state.selectedNodeId = state.tree[0]?.id || null;
    }else if(Array.isArray(data.quests)){
      const node=currentNode() || (state.tree[0]??null);
      if(node){ node.quests=node.quests||[]; for(const q of data.quests){ node.quests.push({ id:uid(), name:q.name||q.title||"", desc:q.desc||q.description||"", done:!!q.done, open:false, editing:false }); } }
    }else{
      throw new Error("Unrecognized JSON shape");
    }
  }catch{
    const node=currentNode() || (state.tree[0]??null);
    if(!node) return;
    const lines=String(text).split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    node.quests=node.quests||[];
    for(const line of lines){ node.quests.push({ id:uid(), name:line, desc:"", done:false, open:true, editing:false }); }
  }
  save(); render();
}

/* ================== Connect / Create / Save / Share ================== */
el("connectFileBtn").onclick=async ()=>{
  let handle=null, file=null;
  if(supportsFS){ try{ const [h]=await window.showOpenFilePicker({ types:[{ description:"JSON or Text", accept:{ "application/json":[".json"], "text/plain":[".txt"], "application/octet-stream":[".*"] } }], excludeAcceptAllOption:false, multiple:false }); handle=h; file=await h.getFile(); }catch(e){} }
  if(!file){
    const input=document.createElement("input"); input.type="file"; input.accept=".json,.txt"; input.style.display="none"; document.body.appendChild(input);
    const picked=await new Promise(res=>{ input.onchange=()=>res(input.files?.[0]||null); input.click(); });
    document.body.removeChild(input); if(!picked) return; file=picked;
  }
  const text=await file.text();
  try{
    const data=text.trim()? JSON.parse(text) : {tree:[]};
    if(Array.isArray(data.tree)) state=data;
    else if(Array.isArray(data.sections)){
      state={ tree:data.sections.map(s=>({id:uid(),title:s.title||"Untitled",open:true,quests:s.quests||[],children:[] })), selectedNodeId:null };
      state.selectedNodeId = state.tree[0]?.id || null;
    }else{ await importFromText(text); }
  }catch{ await importFromText(text); }
  save(); render();

  if(handle && supportsFS && secureOK){
    fileHandle=handle;
    try{ await writeToHandle(fileHandle); setStatus(`Saving to: ${fileHandle.name}`); stampSaved("connected file", fileHandle.name); warnFS(""); }
    catch(err){ fileHandle=null; setStatus(`Loaded (read-only): ${file.name}`); warnFS("Could not enable auto-save: " + (err?.message||err)); }
  }else{
    fileHandle=null; setStatus(`Loaded (read-only): ${file.name}`);
    if(supportsFS && !secureOK){ warnFS("To save back to the file, open via http://localhost or HTTPS."); }
    else if(!supportsFS){ warnFS("Your browser doesn’t support direct file saving. Use Save/Share/Export."); }
    else { warnFS(""); }
  }
};
el("createFileBtn").onclick=async ()=>{
  if(!(supportsFS && secureOK)){ warnFS("Use Chrome/Edge/Brave/Opera and open via http://localhost or HTTPS to create & save to files."); return; }
  try{
    const handle=await window.showSaveFilePicker({ suggestedName:"mnm-questlog.json", types:[{ description:"JSON", accept:{ "application/json":[".json"] } }] });
    fileHandle=handle; await writeToHandle(fileHandle);
    setStatus(`Saving to: ${fileHandle.name}`); stampSaved("new file", fileHandle.name); warnFS("");
  }catch(e){}
};
el("saveBtn").onclick = hardSave;
el("shareBtn").onclick = shareJSON;
window.addEventListener("keydown",(e)=>{ if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==="s"){ e.preventDefault(); hardSave(); }});

/* ================== Wiring ================== */
const collapsed = localStorage.getItem(SIDEBAR_KEY)==="1";
if(collapsed) document.body.classList.add("sidebar-collapsed");
updateSidebarToggleLabel();
el("sidebarToggle").onclick=()=>{ document.body.classList.toggle("sidebar-collapsed"); localStorage.setItem(SIDEBAR_KEY, document.body.classList.contains("sidebar-collapsed")?"1":"0"); updateSidebarToggleLabel(); };
function updateSidebarToggleLabel(){ el("sidebarToggle").textContent = document.body.classList.contains("sidebar-collapsed") ? "▸" : "◂"; }

/* Buttons */
el("expandAllBtn").onclick = expandAll;
el("collapseAllBtn").onclick = collapseAll;
el("addCharacterBtn").onclick = addCharacter;
el("addChildBtn").onclick = addChild;
el("renameNodeBtn").onclick = renameNode;
el("deleteNodeBtn").onclick = deleteNode;

/* Add Quest handlers (click + form submit + Ctrl/Cmd+Enter in description) */
el("addQuestForm").addEventListener("submit", (e)=>{ e.preventDefault(); addQuest(); });
el("addQuestBtn").addEventListener("click", (e)=>{ e.preventDefault(); addQuest(); });
el("questDesc").addEventListener("keydown", (e)=>{
  if((e.ctrlKey||e.metaKey) && e.key==="Enter"){ e.preventDefault(); addQuest(); }
});

/* Other quest tools */
el("markAllDoneBtn").onclick = markAllDone;
el("purgeDoneBtn").onclick = purgeDone;

el("exportBtn").onclick = exportJSON;
el("importFile").onchange = (e)=>{ const f=e.target.files?.[0]; if(!f) return; readAndImportFile(f); };
el("pasteToggleBtn").onclick = ()=>{
  const box=el("pasteBox"), btn=el("pasteLoadBtn");
  const show = box.style.display!=="block";
  box.style.display = show?"block":"none";
  btn.style.display = show?"block":"none";
  if(show) box.focus();
};
el("pasteLoadBtn").onclick = ()=>{ const t=el("pasteBox").value.trim(); if(!t) return; importFromText(t); el("pasteBox").value=""; el("pasteBox").style.display="none"; el("pasteLoadBtn").style.display="none"; };
el("clearAllBtn").onclick = ()=>{ if(confirm("Clear all data?")){ localStorage.removeItem(STORAGE_KEY); state=defaultState(); save(); render(); } };

/* ============ Add Quest logic (robust) ============ */
function addQuest(){
  const node = currentNode();
  if(!node){ alert("Select a character/sub-section first."); return false; }

  const nameInput = el("questName");
  const descInput = el("questDesc");
  const err = el("addQuestError");

  let n = (nameInput.value || "").trim();
  const d = (descInput.value || "").trim();

  if(!n && !d){
    err.style.display = "block";
    return false;
  }
  err.style.display = "none";

  if(!n && d){
    n = d.split(/\r?\n/)[0].slice(0, 60) || "Untitled quest";
  }

  node.quests = node.quests || [];
  node.quests.unshift({ id: uid(), name: n, desc: d, done: false, open: true, editing: false });

  nameInput.value = "";
  descInput.value = "";
  save(); 
  render();
  nameInput.focus();
  return true;
}

/* Initial render */
render();
</script>
</body>
</html>
