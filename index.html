<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Monsters & Memories — Quest Log (GitHub Save: strict)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#111418;--panel:#1b1f26;--muted:#8ea0b5;--accent:#ffd166;--accent-2:#06d6a0;--danger:#ef476f;
    --text:#e9eef5;--text-dim:#b7c4d4;--card:#202632;--card-2:#283243;--border:#2b3442;--radius:12px;
    --sidebar-w:300px; --sidebar-w-collapsed:48px;
  }
  *{box-sizing:border-box}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font:15px/1.4 system-ui,Segoe UI,Roboto,Inter,Ubuntu,Arial;
    display:grid; grid-template-columns:var(--sidebar-w) 1fr; grid-template-rows:auto 1fr;
    min-height:100vh; transition:grid-template-columns .2s ease;
  }
  body.sidebar-collapsed{ grid-template-columns:var(--sidebar-w-collapsed) 1fr; }

  header{grid-column:1/-1; padding:10px 16px; background:linear-gradient(180deg,#141922,transparent); border-bottom:1px solid var(--border)}
  h1{margin:0; font-size:20px; color:var(--accent)}
  .wrap{display:contents}

  /* Sidebar (tree) */
  .sidebar{border-right:1px solid var(--border); background:var(--panel); display:flex; flex-direction:column; overflow:hidden}
  .sidebar-head{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px; border-bottom:1px solid var(--border)}
  .sidebar-title{font-size:12px; color:var(--muted); letter-spacing:.06em; text-transform:uppercase}
  .sidebar-toggle{border:1px solid var(--border); background:#ffffff10; color:#fff; border-radius:10px; padding:6px 10px; cursor:pointer; font-size:12px}

  .sidebar-inner{padding:8px; display:flex; flex-direction:column; gap:10px; overflow:auto}
  body.sidebar-collapsed .sidebar-title, body.sidebar-collapsed .sidebar-inner{display:none}

  .tree{display:block}
  .tree-row{
    display:flex; align-items:center; gap:8px;
    padding:6px 8px; border-radius:10px; border:1px solid transparent; cursor:pointer;
  }
  .tree-row:hover{ background:#ffffff08; }
  .tree-row.active{ background:var(--card-2); border-color:var(--accent); }
  .twisty{width:18px; text-align:center; user-select:none; font-size:12px; opacity:.9}
  .twisty.invisible{visibility:hidden}
  .node-title{flex:1; min-width:0}
  .title-text{white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
  .badge{font-size:11px; background:var(--accent-2); color:#06261e; padding:2px 8px; border-radius:999px; font-weight:700}

  .mini-actions{display:grid; grid-template-columns:1fr 1fr; gap:6px}
  .sidebar-actions{display:grid; grid-template-columns:1fr 1fr; gap:6px}

  /* Main controls */
  .input,.textarea{width:100%; padding:9px 11px; border-radius:10px; background:#0f1319; border:1px solid var(--border); color:#fff}
  .textarea{min-height:90px; resize:vertical}
  .btn{border:none; border-radius:10px; padding:6px 10px; cursor:pointer; font-size:13px}
  .btn.secondary{background:#ffffff14; color:#fff}
  .btn.danger{background:var(--danger); color:#fff}
  .btn.success{background:var(--accent-2); color:#06261e}
  .btn.main{background:var(--accent); color:#1a1a1a; font-weight:700}
  .chip{background:#ffffff14; color:#b7c4d4; padding:6px 10px; border-radius:999px; border:1px solid var(--border); font-size:12px}

  /* Main area */
  .main{padding:8px 16px 16px; overflow:auto; display:flex; flex-direction:column; gap:12px}
  .card{background:var(--card); border:1px solid var(--border); border-radius:var(--radius); padding:12px}
  .empty{padding:14px; border:1px dashed var(--border); border-radius:12px; color:#aaa; text-align:center}
  .storage-row{display:flex; gap:8px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  .subtle{color:var(--text-dim); font-size:12px; margin-top:6px}

  .grid-2{display:grid; grid-template-columns:1fr; gap:12px; align-items:start}
  @media (min-width: 860px){ .grid-2{grid-template-columns:1fr auto} }
  details.add, details.tools{border:1px solid var(--border); border-radius:12px; background:var(--card)}
  details.add>summary, details.tools>summary{list-style:none; cursor:pointer; padding:12px; user-select:none; display:flex; align-items:center; justify-content:space-between; font-weight:700}
  details.add[open]>summary, details.tools[open]>summary{border-bottom:1px solid var(--border)}
  details.add .content, details.tools .content{padding:12px}

  /* Quests */
  .quest{background:var(--panel); border:1px solid var(--border); border-radius:12px; margin-top:8px}
  .quest.done{opacity:.72}
  .quest-header{display:flex; justify-content:space-between; align-items:center; padding:10px 12px; cursor:pointer}
  .quest-name{font-weight:700}
  .quest-body{display:none; padding:10px 12px 12px; border-top:1px solid var(--border)}
  .quest.open .quest-body{display:block}
  .muted{color:var(--text-dim); white-space:pre-wrap; margin:8px 0}
  .stack-h{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}

  /* Floating inline editor for node titles (horizontal) */
  .floating-editor{
    position:fixed; z-index:9999; display:flex; gap:6px; align-items:center;
    background:var(--panel); border:1px solid var(--border); border-radius:10px; padding:6px;
    box-shadow:0 8px 24px rgba(0,0,0,.5);
  }
  .floating-input{
    font-size:14px; line-height:1.25;
    background:#0f1319; color:#fff; border:1px solid var(--border); border-radius:8px;
    padding:6px 8px; white-space:nowrap; overflow:hidden;
  }
  .icon-btn{border:none; background:#ffffff14; color:#fff; padding:6px 10px; border-radius:8px; cursor:pointer; font-size:12px}
  .icon-btn.secondary{background:#ffffff10; color:#b7c4d4}
  .icon-btn:hover{background:#ffffff22}
</style>
</head>
<body>
<header><h1>Monsters & Memories — Quest Log</h1></header>

<div class="wrap">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="sidebar-head">
      <div class="sidebar-title">Characters & Sub-sections</div>
      <button id="sidebarToggle" class="sidebar-toggle" title="Toggle sidebar">◂</button>
    </div>
    <div class="sidebar-inner">
      <div id="tree" class="tree"></div>

      <div class="mini-actions">
        <button id="expandAllBtn" class="btn secondary" title="Expand all nodes">Expand All</button>
        <button id="collapseAllBtn" class="btn secondary" title="Collapse all nodes">Collapse All</button>
      </div>

      <div class="sidebar-actions">
        <button id="addCharacterBtn" class="btn main">Add Character</button>
        <button id="addChildBtn" class="btn secondary">Add Sub-section</button>
        <button id="renameNodeBtn" class="btn secondary">Rename</button>
        <button id="deleteNodeBtn" class="btn danger">Delete</button>
      </div>

      <div class="card" style="margin-top:8px">
        <button id="exportBtn" class="btn secondary" style="width:100%">Export (JSON)</button>
        <input id="importFile" type="file" accept=".json,.txt" class="input" />
        <button id="clearAllBtn" class="btn danger" style="width:100%">Clear All</button>
      </div>
    </div>
  </aside>

  <!-- Main -->
  <main class="main">
    <div class="card">
      <div class="storage-row">
        <div id="fileStatus" class="chip">Storage: Local (browser)</div>
        <div class="stack-h">
          <!-- Local file options kept as fallback -->
          <button id="connectFileBtn" class="btn secondary" title="Connect a local file (fallback)">Local File</button>
          <button id="saveBtn" class="btn success" title="Save (Ctrl/Cmd+S)">Save</button>
        </div>
      </div>
      <div id="fsWarning" class="subtle" style="display:none"></div>
      <div id="lastSaved" class="subtle">Last saved: —</div>
    </div>

    <!-- GitHub connection panel -->
    <details class="tools" open>
      <summary>GitHub File</summary>
      <div class="content" style="display:grid; gap:8px">
        <div style="display:grid; gap:8px; grid-template-columns:repeat(auto-fit,minmax(180px,1fr))">
          <input id="ghOwner" class="input" placeholder="owner (user or org)" value="Khristory" />
          <input id="ghRepo" class="input" placeholder="repo name" value="MnM-Quest-Log" />
          <input id="ghBranch" class="input" placeholder="branch (e.g., main)" value="main" />
          <input id="ghPath" class="input" placeholder="path/to/questlog.json" value="mnm-questlog.json" />
          <input id="ghToken" class="input" placeholder="GitHub token (needed to save)" value="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" />
        </div>
        <label class="subtle" style="display:flex; align-items:center; gap:8px">
          <input id="ghRemember" type="checkbox" />
          Remember token locally (browser storage)
        </label>
        <div class="stack-h">
          <button id="ghConnectBtn" class="btn main">Connect GitHub</button>
          <button id="ghDisconnectBtn" class="btn secondary">Disconnect</button>
        </div>
        <div id="ghMsg" class="subtle"></div>
      </div>
    </details>

    <div id="crumb" class="card">No node selected</div>

    <div class="grid-2">
      <!-- Add Quest -->
      <details class="add" open>
        <summary>Add Quest</summary>
        <div class="content">
          <form id="addQuestForm" style="display:grid; gap:8px">
            <input id="questName" class="input" placeholder="Quest name" />
            <textarea id="questDesc" class="textarea" placeholder="Description / objectives / NPC notes…"></textarea>
            <div style="display:flex; justify-content:flex-end; gap:8px">
              <button id="addQuestBtn" type="submit" class="btn main">Add Quest</button>
            </div>
            <div id="addQuestError" style="display:none; color:#ef9aa8; font-size:12px">
              Please enter a name or a description.
            </div>
          </form>
        </div>
      </details>

      <!-- Node Tools -->
      <details class="tools" open>
        <summary>Node Tools</summary>
        <div class="content">
          <div class="stack-h">
            <button id="markAllDoneBtn" class="btn secondary">Mark All Done</button>
            <button id="purgeDoneBtn" class="btn danger">Delete Done</button>
          </div>
        </div>
      </details>
    </div>

    <div class="card">
      <strong>Quests</strong>
      <div id="questList"></div>
      <div id="emptyState" class="empty" style="display:none">No quests yet in this node</div>
    </div>
  </main>
</div>

<script>
/* ================== Core state ================== */
const STORAGE_KEY="mnm_tree_questlog_v1";
const SIDEBAR_KEY="mnm_sidebar_collapsed";
const GH_CFG_KEY="mnm_gh_cfg_v1";
const GH_TOKEN_KEY="mnm_gh_token_v1";

let state = load();
let fileHandle = null;

/* GitHub connection state */
let gh = {
  owner:"", repo:"", branch:"main", path:"mnm-questlog.json",
  token:null, sha:null, connected:false
};

const supportsFS = !!(window.showOpenFilePicker && window.showSaveFilePicker);
const secureOK = window.isSecureContext || location.protocol==="https:" || location.hostname==="localhost";
const el = (id)=>document.getElementById(id);

/* ========= Utils ========= */
function uid(){ return Math.random().toString(36).slice(2,9); }
function encodeB64(str){ return btoa(unescape(encodeURIComponent(str))); }
function decodeB64(str){ return decodeURIComponent(escape(atob(str))); }

/* ========= Persistence ========= */
function save(data=state){ localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }
function load(){
  try{
    const raw=localStorage.getItem(STORAGE_KEY);
    if(raw){ const s=JSON.parse(raw); if(s.tree) return s; }
  }catch{}
  const rootId=uid();
  return { tree:[{id:rootId,title:"Main Character",open:true,quests:[],children:[]}], selectedNodeId:rootId };
}
function setStatus(msg){ el("fileStatus").textContent = msg; }
function setGhMsg(s){ el("ghMsg").textContent = s||""; }
function warnFS(msg){ const w=el("fsWarning"); w.textContent=msg; w.style.display=msg? "block":"none"; }
function stampSaved(method, name){ const ts=new Date().toLocaleString(); el("lastSaved").textContent = `Last saved: ${ts} via ${method}${name?` (${name})`:""}`; }

/* ========= Local File (fallback) ========= */
async function ensurePermission(){
  if(!fileHandle) return false;
  let p=await fileHandle.queryPermission({mode:'readwrite'});
  if(p==='prompt') p=await fileHandle.requestPermission({mode:'readwrite'});
  return p==='granted';
}
async function writeToHandle(handle){
  const w=await handle.createWritable();
  await w.write(JSON.stringify(state,null,2));
  await w.close();
}

/* ========= GitHub API ========= */
function persistGhToLocal(){
  const cfg = { owner:gh.owner, repo:gh.repo, branch:gh.branch, path:gh.path };
  localStorage.setItem(GH_CFG_KEY, JSON.stringify(cfg));
  const remember = el("ghRemember")?.checked;
  if(remember && gh.token){ localStorage.setItem(GH_TOKEN_KEY, gh.token); }
  else { localStorage.removeItem(GH_TOKEN_KEY); }
}
function loadGhFromLocal(){
  try{
    const cfg = JSON.parse(localStorage.getItem(GH_CFG_KEY)||"{}");
    gh.owner = cfg.owner||gh.owner;
    gh.repo  = cfg.repo ||gh.repo;
    gh.branch= cfg.branch||gh.branch;
    gh.path  = cfg.path ||gh.path;
  }catch{}
  const savedToken = localStorage.getItem(GH_TOKEN_KEY);
  if(savedToken){ gh.token=savedToken; if(el("ghRemember")) el("ghRemember").checked=true; }
  // reflect in inputs
  el("ghOwner").value = gh.owner;
  el("ghRepo").value  = gh.repo;
  el("ghBranch").value= gh.branch;
  el("ghPath").value  = gh.path;
  el("ghToken").value = gh.token||"";
}
async function ghFetchFile(){
  if(!gh.owner||!gh.repo||!gh.path||!gh.branch){ throw new Error("Missing owner/repo/branch/path"); }
  const url = `https://api.github.com/repos/${encodeURIComponent(gh.owner)}/${encodeURIComponent(gh.repo)}/contents/${gh.path}?ref=${encodeURIComponent(gh.branch)}`;
  const headers = { "Accept":"application/vnd.github+json" };
  if(gh.token) headers["Authorization"] = "token " + gh.token;
  const res = await fetch(url, {headers});
  if(res.status===404){
    gh.sha=null; // file doesn't exist yet
    return { exists:false, content:null };
  }
  if(!res.ok){ const t=await res.text(); throw new Error(`GitHub GET failed: ${res.status} ${t}`); }
  const data = await res.json();
  gh.sha = data.sha || null;
  const text = decodeB64(data.content || "");
  return { exists:true, content:text };
}
async function ghSaveFile(){
  if(!gh.owner||!gh.repo||!gh.path||!gh.branch) throw new Error("Fill owner/repo/branch/path.");
  if(!gh.token) throw new Error("Token required to save to GitHub.");

  const url = `https://api.github.com/repos/${encodeURIComponent(gh.owner)}/${encodeURIComponent(gh.repo)}/contents/${gh.path}`;
  const body = {
    message: `Update questlog (${new Date().toLocaleString()})`,
    content: encodeB64(JSON.stringify(state,null,2)),
    branch: gh.branch
  };
  if(gh.sha) body.sha = gh.sha;
  const headers = {
    "Accept":"application/vnd.github+json",
    "Content-Type":"application/json",
    "Authorization":"token " + gh.token
  };
  let res = await fetch(url, {method:"PUT", headers, body:JSON.stringify(body)});
  if(res.status===409){
    try{
      await ghFetchFile(); body.sha = gh.sha;
      res = await fetch(url, {method:"PUT", headers, body:JSON.stringify(body)});
    }catch(e){}
  }
  if(!res.ok){ const t=await res.text(); throw new Error(`GitHub PUT failed: ${res.status} ${t}`); }
  const data = await res.json();
  gh.sha = data.content?.sha || gh.sha;
  setStatus(`GitHub: ${gh.owner}/${gh.repo}@${gh.branch}:${gh.path}`);
  stampSaved("GitHub", `${gh.owner}/${gh.repo}@${gh.branch}:${gh.path}`);
  setGhMsg("Saved to GitHub.");
}

/* ========= Save hub (strict) ========= */
async function hardSave(){
  // If connected to GitHub, require saving to GitHub (no local fallback)
  if (gh.connected) {
    if (!gh.token) { setGhMsg("Token required to save to GitHub."); return; }
    try { await ghSaveFile(); } catch (err) { setGhMsg(String(err.message || err)); }
    return;
  }

  // Fallback paths only when NOT connected to GitHub
  if (fileHandle && supportsFS && secureOK) {
    try {
      if (await ensurePermission()) {
        await writeToHandle(fileHandle);
        setStatus(`Saved to: ${fileHandle.name}`); stampSaved("connected file", fileHandle.name);
        return;
      }
    } catch (e) {}
  }
  if (supportsFS && secureOK) {
    try {
      const handle = await window.showSaveFilePicker({
        suggestedName: (fileHandle?.name) || "mnm-questlog.json",
        types: [{ description: "JSON", accept: { "application/json": [".json"] } }]
      });
      await writeToHandle(handle);
      fileHandle = handle;
      setStatus(`Saved to: ${fileHandle.name}`); stampSaved("Save As", fileHandle.name);
      return;
    } catch (e) {}
  }
  const blob = new Blob([JSON.stringify(state, null, 2)], { type: "application/json" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob); a.download = (fileHandle?.name) || "mnm-questlog.json"; a.click();
  setStatus("Downloaded JSON"); stampSaved("download");
}

/* ========= Tree helpers ========= */
function findNodeAndParent(id){
  function walk(nodes, parent=null, path=[]){
    for(const n of nodes){
      const np=[...path,n];
      if(n.id===id) return {node:n, parent, path:np};
      if(n.children?.length){ const r=walk(n.children, n, np); if(r) return r; }
    } return null;
  } return walk(state.tree, null, []);
}
function currentNode(){ const sel=state.selectedNodeId; if(!sel) return state.tree[0]||null; const r=findNodeAndParent(sel); return r?.node || (state.tree[0]||null); }
function countsForNode(node){ const total=node.quests?.length||0; const done=(node.quests||[]).filter(q=>q.done).length; return {done,total}; }
function setOpenRecursive(node, open){ node.open=open; node.children?.forEach(ch=>setOpenRecursive(ch,open)); }
function expandAll(){ state.tree.forEach(n=>setOpenRecursive(n,true)); save(); renderTree(); }
function collapseAll(){ state.tree.forEach(n=>setOpenRecursive(n,false)); save(); renderTree(); }

/* ========= Floating inline editor for section titles ========= */
let floating = null, floatingInput = null, widthMirror = null, editingId = null;
function ensureMirror(){
  if(!widthMirror){
    widthMirror = document.createElement("span");
    widthMirror.style.position="fixed"; widthMirror.style.visibility="hidden"; widthMirror.style.whiteSpace="pre";
    widthMirror.style.font="14px/1.25 system-ui,Segoe UI,Roboto,Inter,Ubuntu,Arial";
    widthMirror.style.padding="0 8px"; widthMirror.style.border="1px solid transparent";
    document.body.appendChild(widthMirror);
  }
}
function autosizeInput(){
  if(!floatingInput) return;
  ensureMirror();
  widthMirror.textContent = floatingInput.value || " ";
  const w = Math.min(900, Math.max(180, widthMirror.offsetWidth + 20));
  floatingInput.style.width = w + "px";
}
function positionFloating(){
  if(!floating || !editingId) return;
  const row = document.querySelector(`.tree-row[data-node="${editingId}"]`);
  if(!row) return;
  const rect = row.getBoundingClientRect();
  const left = rect.left + 22 + window.scrollX;
  const top  = rect.top + window.scrollY - 2;
  floating.style.left = left + "px";
  floating.style.top  = top + "px";
}
function startEditNodeTitle(id){
  editingId = id;
  const r = findNodeAndParent(id); if(!r) return;
  if(floating) floating.remove();
  floating = document.createElement("div");
  floating.className = "floating-editor";
  floating.setAttribute("data-node", id);

  floatingInput = document.createElement("input");
  floatingInput.type="text";
  floatingInput.className="floating-input";
  floatingInput.value = r.node.title || "";
  autosizeInput();

  const saveBtn = document.createElement("button"); saveBtn.className="icon-btn"; saveBtn.textContent="Save";
  const cancelBtn = document.createElement("button"); cancelBtn.className="icon-btn secondary"; cancelBtn.textContent="Cancel";

  saveBtn.onclick = ()=> commitEditNodeTitle(id, floatingInput.value);
  cancelBtn.onclick = ()=> cancelEditNodeTitle();

  floatingInput.addEventListener("input", autosizeInput);
  floatingInput.addEventListener("keydown",(e)=>{
    if(e.key==="Enter"){ e.preventDefault(); commitEditNodeTitle(id, floatingInput.value); }
    if(e.key==="Escape"){ e.preventDefault(); cancelEditNodeTitle(); }
  });

  floating.append(floatingInput, saveBtn, cancelBtn);
  document.body.appendChild(floating);
  positionFloating();
  requestAnimationFrame(()=>{ floatingInput.focus(); floatingInput.select(); autosizeInput(); });

  window.addEventListener("scroll", positionFloating, {passive:true});
  window.addEventListener("resize", positionFloating);
}
function commitEditNodeTitle(id, value){
  const r=findNodeAndParent(id); if(!r) return cancelEditNodeTitle();
  const next=(value||"").trim() || "Untitled";
  r.node.title = next;
  cancelEditNodeTitle();
  save(); render();
}
function cancelEditNodeTitle(){
  editingId = null;
  if(floating){ floating.remove(); floating=null; }
  floatingInput=null;
  window.removeEventListener("scroll", positionFloating);
  window.removeEventListener("resize", positionFloating);
}

/* ========= Render UI ========= */
function render(){ renderTree(); renderCrumb(); renderQuests(); }
function renderTree(){
  const host=el("tree"); host.innerHTML="";
  function row(node, depth){
    const r=document.createElement("div");
    r.className="tree-row"+(node.id===state.selectedNodeId?" active":"");
    r.style.paddingLeft = (8 + depth*16) + "px";
    r.setAttribute("data-node", node.id);

    const twist=document.createElement("div");
    twist.className="twisty"+((node.children?.length)? "" : " invisible");
    twist.textContent = node.open? "▾" : "▸";
    twist.title="Click to toggle. Alt+Click toggles entire subtree.";
    twist.onclick=(e)=>{ e.stopPropagation(); if(e.altKey){ setOpenRecursive(node, !node.open); } else { node.open=!node.open; } save(); renderTree(); };

    const titleWrap=document.createElement("div"); titleWrap.className="node-title";
    const text=document.createElement("div"); text.className="title-text"; text.textContent=node.title||"Untitled";
    text.title=node.title||"Untitled";
    text.ondblclick=(e)=>{ e.stopPropagation(); startEditNodeTitle(node.id); };
    titleWrap.appendChild(text);

    const {done,total}=countsForNode(node);
    const badge=document.createElement("div"); badge.className="badge"; badge.textContent=`${done}/${total}`;

    r.append(twist,titleWrap,badge);
    r.onclick=()=>{ state.selectedNodeId=node.id; save(); render(); };
    host.appendChild(r);

    if(node.open && node.children?.length){ node.children.forEach(ch=>row(ch, depth+1)); }
  }
  state.tree.forEach(n=>row(n,0));
}
function renderCrumb(){
  const r=findNodeAndParent(state.selectedNodeId);
  if(!r){ el("crumb").textContent="No node selected"; return; }
  el("crumb").textContent = "Path: " + r.path.map(n=>n.title||"Untitled").join(" › ");
}
function renderQuests(){
  const node=currentNode();
  const list=el("questList");
  if(!node){ list.innerHTML=""; el("emptyState").style.display="block"; return; }

  list.innerHTML="";
  const qs=node.quests||[];
  if(qs.length===0){ el("emptyState").style.display="block"; return; }
  el("emptyState").style.display="none";

  qs.forEach(q=>{
    const card=document.createElement("div"); card.className="quest"+(q.done?" done":"")+(q.open?" open":"");
    const head=document.createElement("div"); head.className="quest-header"; head.innerHTML=`<div class="quest-name">${q.name}</div>`;
    head.onclick=()=>{ q.open=!q.open; save(); renderQuests(); };

    const body=document.createElement("div"); body.className="quest-body";
    if(q.editing){
      const nameInput=document.createElement("input"); nameInput.className="input"; nameInput.value=q.name; nameInput.placeholder="Quest name";
      const descTextarea=document.createElement("textarea"); descTextarea.className="textarea"; descTextarea.placeholder="Description…"; descTextarea.value=q.desc||"";
      const actions=document.createElement("div"); actions.className="stack-h";
      const saveBtn=document.createElement("button"); saveBtn.className="btn success"; saveBtn.textContent="Save";
      const cancelBtn=document.createElement("button"); cancelBtn.className="btn secondary"; cancelBtn.textContent="Cancel";
      saveBtn.onclick=(e)=>{e.stopPropagation(); commitEdit(q,nameInput.value,descTextarea.value);};
      cancelBtn.onclick=(e)=>{e.stopPropagation(); cancelEdit(q);};
      nameInput.addEventListener("keydown",(e)=>{ if(e.key==="Enter"&&(e.ctrlKey||e.metaKey)) commitEdit(q,nameInput.value,descTextarea.value); if(e.key==="Escape") cancelEdit(q);});
      descTextarea.addEventListener("keydown",(e)=>{ if(e.key==="Enter"&&(e.ctrlKey||e.metaKey)) commitEdit(q,nameInput.value,descTextarea.value); if(e.key==="Escape") cancelEdit(q);});
      actions.append(saveBtn,cancelBtn); body.append(nameInput,descTextarea,actions);
      setTimeout(()=>nameInput.focus(),0);
    } else {
      const desc=document.createElement("div"); desc.className="muted"; desc.textContent=q.desc||"—";
      const actions=document.createElement("div"); actions.className="stack-h";
      const editBtn=document.createElement("button"); editBtn.className="btn secondary"; editBtn.textContent="Edit";
      const doneBtn=document.createElement("button"); doneBtn.className="btn success"; doneBtn.textContent=q.done?"Undo":"Done";
      const delBtn=document.createElement("button"); delBtn.className="btn danger"; delBtn.textContent="Delete";
      editBtn.onclick=(e)=>{e.stopPropagation(); q.editing=true; q.open=true; save(); renderQuests();};
      doneBtn.onclick=(e)=>{e.stopPropagation(); q.done=!q.done; save(); render();};
      delBtn.onclick=(e)=>{e.stopPropagation(); node.quests=node.quests.filter(x=>x.id!==q.id); save(); render();};
      actions.append(editBtn,doneBtn,delBtn); body.append(desc,actions);
    }
    card.append(head,body); list.appendChild(card);
  });
}
function commitEdit(q, nextName, nextDesc){ const name=(nextName||"").trim(); const desc=(nextDesc||"").trim(); if(name) q.name=name; q.desc=desc; q.editing=false; q.open=true; save(); render(); }
function cancelEdit(q){ q.editing=false; save(); renderQuests(); }

/* ========= Node actions ========= */
function addCharacter(){ const id=uid(); state.tree.push({ id, title:"New Character", open:true, quests:[], children:[] }); state.selectedNodeId=id; save(); render(); startEditNodeTitle(id); }
function addChild(){ const sel=currentNode(); if(!sel) return alert("Select a node first."); const id=uid(); sel.children=sel.children||[]; sel.open=true; sel.children.push({ id, title:"New Sub-section", open:true, quests:[], children:[] }); state.selectedNodeId=id; save(); render(); startEditNodeTitle(id); }
function renameNode(){ const sel=currentNode(); if(!sel) return alert("Select a node first."); startEditNodeTitle(sel.id); }
function deleteNode(){
  const r=findNodeAndParent(state.selectedNodeId); if(!r) return alert("Select a node first.");
  if(!confirm(`Delete "${r.node.title}" and everything inside it?`)) return;
  if(r.parent){ r.parent.children=(r.parent.children||[]).filter(x=>x.id!==r.node.id); state.selectedNodeId=r.parent.id; }
  else{ state.tree=state.tree.filter(x=>x.id!==r.node.id); state.selectedNodeId=state.tree[0]?.id||null; }
  save(); render();
}

/* ========= Import/Export (manual) ========= */
function exportJSON(){ const blob=new Blob([JSON.stringify(state,null,2)],{type:"application/json"}); const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="mnm-questlog.json"; a.click(); }
async function readAndImportFile(file){
  const text=await file.text();
  try{
    const data=JSON.parse(text);
    if(Array.isArray(data.tree)){
      state=data;
    }else if(Array.isArray(data.sections)){
      state={ tree:data.sections.map(s=>({id:uid(),title:s.title||"Untitled",open:true,quests:s.quests||[],children:[] })), selectedNodeId:null };
      state.selectedNodeId = state.tree[0]?.id || null;
    }else if(Array.isArray(data.quests)){
      const node=currentNode() || (state.tree[0]??null);
      if(node){ node.quests=node.quests||[]; for(const q of data.quests){ node.quests.push({ id:uid(), name:q.name||q.title||"", desc:q.desc||q.description||"", done:!!q.done, open:false, editing:false }); } }
    }
  }catch{
    const node=currentNode() || (state.tree[0]??null);
    if(!node) return;
    const lines=String(text).split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    node.quests=node.quests||[];
    for(const line of lines){ node.quests.push({ id:uid(), name:line, desc:"", done:false, open:true, editing:false }); }
  }
  save(); render();
}

/* ========= Connectors & Buttons ========= */
// Local file (fallback)
el("connectFileBtn").onclick=async ()=>{
  let handle=null, file=null;
  if(supportsFS){
    try{
      const [h]=await window.showOpenFilePicker({
        types:[{ description:"JSON or Text", accept:{ "application/json":[".json"], "text/plain":[".txt"], "application/octet-stream":[".*"] } }],
        excludeAcceptAllOption:false, multiple:false
      });
      handle=h; file=await h.getFile();
    }catch(e){}
  }
  if(!file){
    const input=document.createElement("input"); input.type="file"; input.accept=".json,.txt"; input.style.display="none";
    document.body.appendChild(input);
    const picked=await new Promise(res=>{ input.onchange=()=>res(input.files?.[0]||null); input.click(); });
    document.body.removeChild(input);
    if(!picked) return;
    file=picked;
  }
  await readAndImportFile(file);
  save(); render();

  if(handle && supportsFS && secureOK){
    fileHandle=handle;
    try{ await writeToHandle(fileHandle); setStatus(`Saving to: ${fileHandle.name}`); stampSaved("connected file", fileHandle.name); warnFS(""); }
    catch(err){ fileHandle=null; setStatus(`Loaded (read-only): ${file.name}`); warnFS("Could not enable auto-save: " + (err?.message||err)); }
  }else{
    fileHandle=null; setStatus(`Loaded (read-only): ${file.name}`);
  }
};

// GitHub panel
function readGhForm(){
  gh.owner = el("ghOwner").value.trim();
  gh.repo  = el("ghRepo").value.trim();
  gh.branch= el("ghBranch").value.trim() || "main";
  gh.path  = el("ghPath").value.trim() || "mnm-questlog.json";
  gh.token = (el("ghToken").value||"").trim() || null;
}
function updateSaveButton(){
  const btn = el("saveBtn");
  if(!btn) return;
  if(gh.connected){
    btn.textContent = gh.token ? "Save to GitHub" : "Save to GitHub (token required)";
    btn.disabled = !gh.token;
  }else{
    btn.textContent = "Save";
    btn.disabled = false;
  }
}
el("ghConnectBtn").onclick = async ()=>{
  try{
    readGhForm();
    persistGhToLocal();
    setGhMsg("Connecting…");
    const r = await ghFetchFile();
    gh.connected = true;
    updateSaveButton();
    setStatus(`GitHub: ${gh.owner}/${gh.repo}@${gh.branch}:${gh.path}`);
    if(r.exists && r.content){
      try{
        const data=JSON.parse(r.content);
        if(data.tree){ state=data; }
        else if(Array.isArray(data.sections)){
          state={ tree:data.sections.map(s=>({id:uid(),title:s.title||"Untitled",open:true,quests:s.quests||[],children:[] })), selectedNodeId:null };
          state.selectedNodeId = state.tree[0]?.id || null;
        }
        save(); render();
        setGhMsg("Loaded from GitHub. Saving will commit back to the same file.");
      }catch{
        setGhMsg("Connected, but file is not valid JSON. Saving will overwrite with JSON.");
      }
    }else{
      setGhMsg("Connected. File does not exist yet; it will be created on Save.");
    }
  }catch(err){
    gh.connected=false;
    updateSaveButton();
    setGhMsg(String(err.message||err));
  }
};
el("ghDisconnectBtn").onclick = ()=>{
  gh.connected=false; gh.sha=null;
  setStatus("Storage: Local (browser)");
  setGhMsg("Disconnected from GitHub.");
  updateSaveButton();
};
el("ghToken").addEventListener("input",(e)=>{
  gh.token = (e.target.value||"").trim() || null;
  updateSaveButton();
});

el("saveBtn").onclick = ()=>{ hardSave(); };
window.addEventListener("keydown",(e)=>{ if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==="s"){ e.preventDefault(); hardSave(); }});

// Sidebar collapse
const collapsed = localStorage.getItem(SIDEBAR_KEY)==="1";
if(collapsed) document.body.classList.add("sidebar-collapsed");
function updateSidebarToggleLabel(){ el("sidebarToggle").textContent = document.body.classList.contains("sidebar-collapsed") ? "▸" : "◂"; }
updateSidebarToggleLabel();
el("sidebarToggle").onclick=()=>{
  document.body.classList.toggle("sidebar-collapsed");
  localStorage.setItem(SIDEBAR_KEY, document.body.classList.contains("sidebar-collapsed")?"1":"0");
  updateSidebarToggleLabel();
};

// Tree buttons
el("expandAllBtn").onclick = expandAll;
el("collapseAllBtn").onclick = collapseAll;
el("addCharacterBtn").onclick = addCharacter;
el("addChildBtn").onclick = addChild;
el("renameNodeBtn").onclick = renameNode;
el("deleteNodeBtn").onclick = deleteNode;

// Add Quest handlers
el("addQuestForm").addEventListener("submit", (e)=>{ e.preventDefault(); addQuest(); });
el("addQuestBtn").addEventListener("click", (e)=>{ e.preventDefault(); addQuest(); });
el("questDesc").addEventListener("keydown", (e)=>{
  if((e.ctrlKey||e.metaKey) && e.key==="Enter"){ e.preventDefault(); addQuest(); }
});

// Other quest tools
el("markAllDoneBtn").onclick = markAllDone;
el("purgeDoneBtn").onclick = purgeDone;

// Manual import/export
el("exportBtn").onclick = exportJSON;
el("importFile").onchange = (e)=>{ const f=e.target.files?.[0]; if(!f) return; readAndImportFile(f); };
el("clearAllBtn").onclick = ()=>{ if(confirm("Clear all data?")){ localStorage.removeItem(STORAGE_KEY); state=load(); save(); render(); } };

// Load saved GH config & set initial Save-button state
loadGhFromLocal();
updateSaveButton();

/* ============ Add Quest logic (robust) ============ */
function addQuest(){
  const node = currentNode();
  if(!node){ alert("Select a character/sub-section first."); return false; }

  const nameInput = el("questName");
  const descInput = el("questDesc");
  const err = el("addQuestError");

  let n = (nameInput.value || "").trim();
  const d = (descInput.value || "").trim();

  if(!n && !d){
    err.style.display = "block";
    return false;
  }
  err.style.display = "none";

  if(!n && d){
    n = d.split(/\r?\n/)[0].slice(0, 60) || "Untitled quest";
  }

  node.quests = node.quests || [];
  node.quests.unshift({ id: uid(), name: n, desc: d, done: false, open: true, editing: false });

  nameInput.value = "";
  descInput.value = "";
  save(); 
  render();
  nameInput.focus();
  return true;
}

/* Initial render */
render();
</script>
</body>
</html>
